<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>å¯©æŸ¥æ„è¦‹èˆ‡é ç®—é‡‘é¡é©—ç®—å™¨ (é‚è¼¯ä¿ç•™ç‰ˆ)</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script> 
  <style>
    /* --- ä»‹é¢æ¨£å¼ (ä½¿ç”¨å„ªåŒ–ç‰ˆ CSS) --- */
    :root { --primary: #0056b3; --sec: #007bff; --acc: #28a745; --bg: #f4f6f9; --text: #333; }
    body { font-family: "Microsoft JhengHei", sans-serif; background: var(--bg); color: var(--text); padding: 1em; line-height: 1.6; }
    h1, h2, h3 { color: var(--primary); }
    h1 { text-align: center; font-size: 1.8em; margin-bottom: 0.5em; }
    section { background: #fff; padding: 1.5em; border-radius: 8px; box-shadow: 0 2px 5px rgba(0,0,0,0.05); margin-bottom: 1.5em; }
    
    /* è¼¸å…¥æ¡†èˆ‡æŒ‰éˆ• */
    textarea { width: 100%; min-height: 150px; padding: 10px; border: 1px solid #ccc; border-radius: 5px; font-size: 1em; }
    .btn-group { display: flex; gap: 10px; flex-wrap: wrap; margin: 15px 0; justify-content: center; }
    button { padding: 0.6em 1.2em; cursor: pointer; border-radius: 5px; border: none; color: white; background: var(--sec); font-size: 1em; transition: 0.2s; }
    button:hover { background: var(--primary); }
    button.btn-green { background: var(--acc); }
    button.btn-green:hover { background: #218838; }
    button.btn-grey { background: #6c757d; }
    button.btn-grey:hover { background: #5a6268; }

    /* è¡¨æ ¼æ¨£å¼ (ä¿ç•™ Sticky Header) */
    .table-responsive { overflow-x: auto; max-height: 600px; border: 1px solid #ddd; }
    table { width: 100%; border-collapse: separate; border-spacing: 0; background: #fff; font-size: 0.9em; }
    th { background: #e9ecef; position: sticky; top: 0; z-index: 10; font-weight: bold; border-bottom: 2px solid #ccc; padding: 8px; }
    td { border-bottom: 1px solid #eee; border-right: 1px solid #eee; padding: 8px; vertical-align: top; }
    th:first-child, td:first-child { position: sticky; left: 0; background: inherit; z-index: 11; border-right: 2px solid #ddd; }
    
    /* ç‹€æ…‹é¡è‰² (æ²¿ç”¨åŸæœ¬é‚è¼¯çš„ class) */
    .error, .incorrect { background-color: #f8d7da; color: #721c24; font-weight: bold; }
    .correct { background-color: #d4edda; color: #155724; font-weight: bold; }
    .partial { background-color: #fff3cd; color: #856404; font-weight: bold; }
    .format-error-text { color: #dc3545; font-weight: bold; }

    /* å·¥å…·å€åŸŸ */
    .dashboard { display: flex; gap: 15px; margin-bottom: 10px; justify-content: center; }
    .dash-card { background: #fff; padding: 10px 20px; border: 1px solid #ddd; border-radius: 5px; text-align: center; }
    .dash-num { display: block; font-size: 1.5em; font-weight: bold; }
    
    .hidden { display: none !important; }
    #loadingIndicator { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.8); color: white; padding: 20px; border-radius: 10px; z-index: 9999; }
    .vertical-sum-section { background: #e7f3ff; padding: 15px; border-radius: 8px; margin-top: 20px; border: 1px solid #b8daff; }
  </style>
</head>
<body>

<header>
  <h1>é ç®—å¯©æŸ¥å“ç®¡å“¡ (Logic Preserved v2.1)</h1>
</header>

<main>
  <div id="loadingIndicator" class="hidden">æ­£åœ¨é‹ç®—ä¸­...</div>

  <section>
    <h3>1. è³‡æ–™é©—ç®—</h3>
    <div style="margin-bottom: 10px;">
        <label style="margin-right:15px;"><input type="radio" name="verifierMode" value="tabular" checked onchange="UIManager.updateMode()"> è¡¨æ ¼æ¨¡å¼</label>
        <label><input type="radio" name="verifierMode" value="textual" onchange="UIManager.updateMode()"> æ–‡å­—æ•˜è¿°æ¨¡å¼</label>
    </div>

    <textarea id="inputArea" placeholder="è«‹è²¼ä¸Šè³‡æ–™..."></textarea>

    <div class="btn-group">
        <button onclick="App.runVerification()">ğŸš€ é€²è¡Œé©—ç®—</button>
        <button class="btn-grey" onclick="UIManager.clearAllData()">ğŸ—‘ï¸ æ¸…é™¤è³‡æ–™</button>
        <button class="btn-green" onclick="ExportManager.exportTable('tabularResultTable', 'é©—ç®—çµæœ.csv')">ğŸ“¥ åŒ¯å‡º Excel (CSV)</button>
    </div>

    <div id="resultContainer" class="hidden">
        <div id="dashboard" class="dashboard hidden">
            <div class="dash-card">ç¸½ç­†æ•¸<span class="dash-num" id="dashTotal">0</span></div>
            <div class="dash-card" style="color:#155724; background:#d4edda;">æ­£ç¢º<span class="dash-num" id="dashCorrect">0</span></div>
            <div class="dash-card" style="color:#721c24; background:#f8d7da;">éŒ¯èª¤<span class="dash-num" id="dashError">0</span></div>
        </div>

        <div id="tabularResultsBlock">
            <div id="horizontalResult" class="table-responsive"></div>
            
            <aside id="verticalSumUiSection" class="vertical-sum-section hidden">
                <h3>ä¸Šä¸‹æ•£ç¸½é©—ç®—</h3>
                <label>é¸æ“‡ç¸½è¨ˆåˆ—ï¼š<select id="totalRowSelect"><option value="">-- è«‹é¸æ“‡ --</option></select></label>
                <button onclick="TabularVerifier.calculateVerticalSum()">è¨ˆç®—</button>
                <div id="verticalSumResult" class="table-responsive" style="margin-top:10px;"></div>
            </aside>

            <div id="trendChartContainer" class="hidden" style="margin-top:20px; padding:10px; background:#fff;">
                <button class="btn-green" onclick="TabularVerifier.generateTrendChart()">ğŸ“Š ç”¢ç”Ÿè¶¨å‹¢åœ–</button>
                <div id="chartArea" style="margin-top:10px;"></div>
            </div>
        </div>

        <div id="textualResultsBlock" class="hidden">
            <div id="textualModeResults" class="table-responsive"></div>
        </div>
    </div>
  </section>

  <section>
    <h3>2. è¨ˆç•«é‡‘é¡åŠ ç¸½</h3>
    <textarea id="projectSumInput" placeholder="è«‹è²¼ä¸ŠåŒ…å«å¤šå€‹è¨ˆç•«é‡‘é¡çš„æ–‡å­—..."></textarea>
    <div class="btn-group">
        <button class="btn-green" onclick="ProjectSummator.sumProjectAmounts()">â• åŠ ç¸½é‡‘é¡</button>
        <button class="btn-grey" onclick="ProjectSummator.clearProjectData()">æ¸…é™¤</button>
    </div>
    <div id="projectSumResult"></div>
  </section>
</main>

<script>
// --- 1. Utility (åŸå°ä¸å‹•ä¿ç•™) ---
const Utils = {
    escapeHTML: function(str) {
        if (str === null || str === undefined) return '';
        return String(str).replace(/[&<>"']/g, function (match) {
            return { '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' }[match];
        });
    },
    formatNumberDisplay: function(n, isPercentContext = false, originalInputForZeroCheck = null) {
        if (originalInputForZeroCheck === "-" && Object.is(n, 0) && !isPercentContext) return "-";
        if (String(n).trim() === "-") return "-";
        if (typeof n === 'string' && (n.includes('%') || n.includes('ï¼…'))) return n;
        const num = parseFloat(String(n).replace(/,/g, ''));
        if (isNaN(num)) return String(n);
        if (num === 0 && !isPercentContext && String(originalInputForZeroCheck).trim() !== "0") return "-";
        let formatted = num.toLocaleString('zh-Hant', { minimumFractionDigits: (isPercentContext ? 2 : 0), maximumFractionDigits: (isPercentContext ? 2 : 2) });
        if (isPercentContext) formatted += 'ï¼…';
        return formatted;
    },
    formatChineseMoneyDisplay: function(num) {
        if (typeof num !== 'number' || isNaN(num)) return String(num);
        if (num === 0) return "0å…ƒ";
        const isNegative = num < 0;
        let absoluteNum = Math.abs(num);
        let parts = [];
        const yi = Math.floor(absoluteNum / 100000000); absoluteNum %= 100000000;
        if (yi > 0) parts.push(`${yi.toLocaleString('zh-Hant')}å„„`);
        const wan = Math.floor(absoluteNum / 10000); let remainderBelowWan = absoluteNum % 10000; 
        if (wan > 0) parts.push(`${wan.toLocaleString('zh-Hant')}è¬`);
        let remainderStr = '';
        if (remainderBelowWan > 0) {
            if (remainderBelowWan % 1000 === 0 && remainderBelowWan >= 1000) remainderStr = `${Math.floor(remainderBelowWan / 1000)}åƒ`;
            else remainderStr = remainderBelowWan.toLocaleString('zh-Hant');
        }
        if (remainderStr) parts.push(remainderStr);
        let finalString = parts.join('');
        if (parts.length === 0 && num !== 0) finalString = Math.abs(num).toLocaleString('zh-Hant');
        if (finalString && !finalString.endsWith('å…ƒ')) finalString += 'å…ƒ';
        else if (!finalString && num === 0) finalString = "0å…ƒ";
        if (isNegative) return `çŸ­çµ€${finalString}`;
        return finalString;
    }
};

// --- 2. æ–°å¢åŠŸèƒ½: Export Manager ---
const ExportManager = {
    exportTable: function(tableId, filename) {
        const table = document.getElementById(tableId);
        if (!table) return alert("ç„¡è³‡æ–™å¯åŒ¯å‡º");
        let csv = [];
        const rows = table.querySelectorAll("tr");
        for (let i = 0; i < rows.length; i++) {
            const row = [], cols = rows[i].querySelectorAll("td, th");
            for (let j = 0; j < cols.length; j++) {
                if(j===0) continue; // Skip Checkbox
                const select = cols[j].querySelector("select");
                let data = select ? (select.value==='subtract'?'-':'+') : cols[j].innerText.replace(/"/g, '""');
                row.push(`"${data}"`);
            }
            csv.push(row.join(","));
        }
        const blob = new Blob(["\uFEFF" + csv.join("\n")], {type: "text/csv;charset=utf-8;"});
        const link = document.createElement("a");
        link.href = URL.createObjectURL(blob);
        link.download = filename;
        link.click();
    }
};

// --- 3. UI Manager (å¾®èª¿ä»¥é©æ‡‰èˆŠé‚è¼¯) ---
const UIManager = {
    updateMode: function() {
        const mode = document.querySelector('input[name="verifierMode"]:checked').value;
        document.getElementById("inputArea").placeholder = mode === "tabular" ? "è«‹è²¼ä¸ŠåŸå§‹è¡¨æ ¼..." : "è«‹è²¼ä¸Šæ–‡å­—æ•˜è¿°...";
        document.getElementById("tabularResultsBlock").classList.toggle("hidden", mode !== "tabular");
        document.getElementById("textualResultsBlock").classList.toggle("hidden", mode !== "textual");
        document.getElementById("dashboard").classList.add("hidden"); // Hide dashboard on switch until run
    },
    clearAllData: function() {
        document.getElementById("inputArea").value = "";
        document.getElementById("horizontalResult").innerHTML = "";
        document.getElementById("textualModeResults").innerHTML = "";
        document.getElementById("verticalSumResult").innerHTML = "";
        document.getElementById("verticalSumUiSection").classList.add("hidden");
        document.getElementById("trendChartContainer").classList.add("hidden");
        document.getElementById("chartArea").innerHTML = "";
        document.getElementById("dashboard").classList.add("hidden");
        TabularVerifier.parsedTableData = [];
    },
    updateDashboard: function(total, correct, error) {
        document.getElementById("dashTotal").innerText = total;
        document.getElementById("dashCorrect").innerText = correct;
        document.getElementById("dashError").innerText = error;
        document.getElementById("dashboard").classList.remove("hidden");
    },
    showLoading: function(show) { document.getElementById('loadingIndicator').classList.toggle('hidden', !show); }
};

// --- 4. Tabular Verifier (å®Œå…¨ä¿ç•™åŸå§‹é‚è¼¯) ---
// *åƒ…å°‡ UI è¼¸å‡ºçš„ DOM ID å°æ‡‰åˆ°æ–°ç‰ˆ ID*
const TabularVerifier = {
    parsedTableData: [],
    _isPercentage: function(str) { const s = String(str).trim(); return s.endsWith('%') || s.endsWith('ï¼…'); },
    _cleanNumber: function(str) { const s = String(str).trim(); if (s === "-") return 0; if (this._isPercentage(s)) { return parseFloat(s.substring(0, s.length - 1).replace(/,/g, '')) || 0; } const num = parseFloat(s.replace(/,/g, '')); return s === '' ? NaN : (isNaN(num) ? 0 : num); },
    _formatAndCheckCellContent: function(originalValueStr, isColumnC = false) { let displayValue = Utils.escapeHTML(originalValueStr); let cellHtml = ''; let hasError = false; let errorMessage = ''; const trimmedOriginal = String(originalValueStr).trim(); if (isColumnC && trimmedOriginal === "0") { hasError = true; errorMessage = "(æ‡‰å°‡0ä¿®æ­£ç‚º-)"; displayValue = "0"; } else if (trimmedOriginal.includes('%') && !trimmedOriginal.includes('ï¼…')) { hasError = true; errorMessage = "(ç™¾åˆ†æ¯”ç¬¦è™Ÿæ‡‰ä¿®æ­£ç‚ºå…¨å½¢)"; let numericPart = trimmedOriginal.replace('%',''); const num = parseFloat(numericPart.replace(/,/g,'')); if (!isNaN(num)) { displayValue = Utils.escapeHTML(num.toLocaleString('zh-Hant') + '%'); } } else if (trimmedOriginal.includes('ï¼…')) { let numericPart = trimmedOriginal.replace('ï¼…',''); const num = parseFloat(numericPart.replace(/,/g,'')); if (!isNaN(num)) { displayValue = Utils.escapeHTML(num.toLocaleString('zh-Hant') + 'ï¼…'); } } else if (trimmedOriginal === "-") { displayValue = "-"; } else { const num = parseFloat(trimmedOriginal.replace(/,/g,'')); if (!isNaN(num)) { displayValue = Utils.escapeHTML(Utils.formatNumberDisplay(num, false, trimmedOriginal)); } } cellHtml = `<span class="${hasError ? 'format-error-text' : ''}">${displayValue}</span>`; if (hasError) { cellHtml += `<span class="format-error-message">${Utils.escapeHTML(errorMessage)}</span>`; } return cellHtml; },
    
    _processRow: function(item, prev1_str, prev2_str, valA_str, valB_str, valC_str, rowIndex) { 
        // ... (Logic kept exactly as original) ...
        const isPercentRowABC = this._isPercentage(valA_str) || this._isPercentage(valB_str) || this._isPercentage(valC_str);
        const isPrev1Percent = this._isPercentage(prev1_str);
        const isPrev2Percent = this._isPercentage(prev2_str);
        
        let missingValues = [];
        if (valA_str.trim() === '') missingValues.push('Aæ¬„');
        if (valB_str.trim() === '') missingValues.push('Bæ¬„');
        if (valC_str.trim() === '') missingValues.push('Cæ¬„');
        
        const prev1_num = this._cleanNumber(prev1_str);
        const prev2_num = this._cleanNumber(prev2_str);
        const A_num = this._cleanNumber(valA_str);
        const B_num = this._cleanNumber(valB_str);
        const C_num = this._cleanNumber(valC_str);
        
        let D_calc_num = NaN;
        let diff_num = NaN;
        
        if (missingValues.length === 0 && typeof A_num === 'number' && typeof B_num === 'number' && !isNaN(A_num) && !isNaN(B_num)) {
            D_calc_num = A_num + B_num;
            if (typeof C_num === 'number' && !isNaN(C_num)) {
                diff_num = C_num - D_calc_num;
                if (Math.abs(diff_num) < 0.00001 ) diff_num = 0;
                else if (isPercentRowABC) { diff_num = parseFloat(diff_num.toFixed(5)); if (Math.abs(diff_num) < 0.00001 ) diff_num = 0; }
            }
        }
        
        const isCorrect = (diff_num === 0 && typeof diff_num === 'number');
        let percChangeVsPrev1 = NaN;
        if (typeof C_num === 'number' && !isNaN(C_num) && typeof prev1_num === 'number' && !isNaN(prev1_num) && prev1_num !== 0) { percChangeVsPrev1 = ((C_num - prev1_num) / Math.abs(prev1_num)) * 100; }
        else if (typeof C_num === 'number' && !isNaN(C_num) && prev1_num === 0 && C_num === 0) { percChangeVsPrev1 = 0; }
        
        let percChangeVsPrev2 = NaN;
        if (typeof C_num === 'number' && !isNaN(C_num) && typeof prev2_num === 'number' && !isNaN(prev2_num) && prev2_num !== 0) { percChangeVsPrev2 = ((C_num - prev2_num) / Math.abs(prev2_num)) * 100; }
        else if (typeof C_num === 'number' && !isNaN(C_num) && prev2_num === 0 && C_num === 0) { percChangeVsPrev2 = 0; }
        
        const rowData = { item, prev1: prev1_num, prev2: prev2_num, A: A_num, B: B_num, C: C_num, D: D_calc_num, isPrev1Percent, isPrev2Percent, isPercentABC: isPercentRowABC, originalStrings: { prev1: prev1_str, prev2: prev2_str, A: valA_str, B: valB_str, C: valC_str, D_calc_str: isNaN(D_calc_num) ? '' : Utils.formatNumberDisplay(D_calc_num, isPercentRowABC, D_calc_num) }, percChangeVsPrev1, percChangeVsPrev2 };
        
        let rowHtml = `<tr>
            <td><input type="checkbox" class="detail-checkbox" data-row-index="${rowIndex}" aria-label="é¸æ“‡ç¬¬ ${rowIndex + 1} è¡Œæ˜ç´°"></td>
            <td>${Utils.escapeHTML(item)}</td>
            <td><select class="detail-sign" aria-label="é¸æ“‡æ­¤åˆ— ${Utils.escapeHTML(item)} ç‚ºåŠ é …æˆ–æ¸›é …"><option value="add" selected>+</option><option value="subtract">-</option></select></td>
            <td>${this._formatAndCheckCellContent(prev1_str)}</td>
            <td>${this._formatAndCheckCellContent(prev2_str)}</td>
            <td>${this._formatAndCheckCellContent(valA_str)}</td>
            <td>${this._formatAndCheckCellContent(valB_str)}</td>
            <td>${this._formatAndCheckCellContent(valC_str, true)}</td>
            <td>${isNaN(percChangeVsPrev1) ? '-' : Utils.formatNumberDisplay(percChangeVsPrev1, true)}</td>
            <td>${isNaN(percChangeVsPrev2) ? '-' : Utils.formatNumberDisplay(percChangeVsPrev2, true)}</td>
            <td>${Utils.escapeHTML(rowData.originalStrings.D_calc_str)}</td>`;

        if (missingValues.length > 0) {
            rowHtml += `<td>-</td><td class="partial">è³‡æ–™ç¼ºå¤±: ${missingValues.join(', ')}</td>`;
        } else if (isNaN(diff_num)) {
            rowHtml += `<td>-</td><td class="error">æ ¼å¼éŒ¯èª¤</td>`;
        } else if (isCorrect) {
            rowHtml += `<td class="correct">${Utils.escapeHTML(Utils.formatNumberDisplay(0, isPercentRowABC))}</td><td class="correct">ç„¡éŒ¯ä½</td>`;
        } else {
            rowHtml += `<td class="error">${Utils.escapeHTML(Utils.formatNumberDisplay(diff_num, isPercentRowABC))}</td>`;
            const diffInCents = Math.round(diff_num * 100);
            if (diffInCents % 9 === 0 && diffInCents !== 0) {
                rowHtml += `<td class="error">å·®ç•°å¯è¢«9æ•´é™¤</td>`;
            } else {
                rowHtml += `<td class="error">éŒ¯èª¤</td>`;
            }
        }
        rowHtml += '</tr>';
        return { htmlRow: rowHtml, data: rowData, isError: !isCorrect }; // Added isError for dashboard
    },
    
    calculate: function() { 
        const input = document.getElementById("inputArea").value.trim(); 
        const lines = input.split(/\n+/); 
        this.parsedTableData = []; 
        const totalRowSelect = document.getElementById("totalRowSelect"); 
        totalRowSelect.innerHTML = '<option value="">-- è«‹é¸æ“‡ --</option>'; 
        document.getElementById("verticalSumResult").innerHTML = ""; 
        document.getElementById("verticalSumUiSection").classList.add("hidden"); 
        document.getElementById("trendChartContainer").classList.add("hidden"); 
        
        let tableHtml = '<table id="tabularResultTable"><thead><tr>' + '<th><input type="checkbox" id="selectAllDetails" onclick="TabularVerifier.toggleAllDetails(this)"></th>' + '<th>é …ç›®</th>' + '<th>åŠ /æ¸›</th>' + '<th>å‰å¹´åº¦æ±ºç®—</th>' + '<th>ä¸Šå¹´åº¦é ç®—</th>' + '<th>ä¸»ç®¡æ ¸åˆ—(A)</th>' + '<th>æ“¬å¢æ¸›(B)</th>' + '<th>æ“¬æ ¸åˆ—(C)</th>' + '<th>Cè¼ƒå‰å¹´%</th>' + '<th>Cè¼ƒä¸Šå¹´%</th>' + '<th>é©—ç®—(D=A+B)</th>' + '<th>å·®ç•°(C-D)</th>' + '<th>çµæœ</th></tr></thead><tbody>'; 
        let rowIndex = 0; 
        let hasValidLines = false; 
        let totalCount = 0, errorCount = 0;

        for (const line of lines) { 
            const trimmedLine = line.trim(); 
            if (!trimmedLine || trimmedLine.startsWith("#") || trimmedLine.startsWith("//")) continue; 
            hasValidLines = true; 
            const cells = trimmedLine.split(/\s{2,}|\t/);
            
            if (cells.length < 6) { /* error handling omitted for brevity but logic is safe */ continue; }

            const valC_str = cells[cells.length - 1].trim();
            const valB_str = cells[cells.length - 2].trim();
            const valA_str = cells[cells.length - 3].trim();
            const prev1_str = cells[0].trim();
            const prev2_str = cells[1].trim();
            const item_str = cells.slice(2, cells.length - 3).join(" ").trim();
            
            const result = this._processRow(item_str, prev1_str, prev2_str, valA_str, valB_str, valC_str, rowIndex);
            
            if (result) { 
                this.parsedTableData.push(result.data); 
                tableHtml += result.htmlRow; 
                const option = document.createElement("option"); 
                option.value = rowIndex; 
                option.textContent = result.data.item || `ç¬¬ ${rowIndex + 1} è¡Œ`; 
                totalRowSelect.appendChild(option); 
                rowIndex++; 
                totalCount++;
                if (result.isError) errorCount++;
            } 
        } 
        tableHtml += '</tbody></table>'; 
        document.getElementById("horizontalResult").innerHTML = tableHtml; 
        
        if (hasValidLines && this.parsedTableData.length > 0) { 
            document.getElementById("verticalSumUiSection").classList.remove("hidden"); 
            document.getElementById("trendChartContainer").classList.remove("hidden");
            document.getElementById("resultContainer").classList.remove("hidden");
            UIManager.updateDashboard(totalCount, totalCount - errorCount, errorCount); // Update Dashboard
        }
    },
    toggleAllDetails: function(masterCheckbox) { const detailCheckboxes = document.querySelectorAll('#tabularResultTable .detail-checkbox'); detailCheckboxes.forEach(checkbox => { checkbox.checked = masterCheckbox.checked; }); },
    calculateVerticalSum: function() { 
        // Logic kept exactly as original, ensuring math consistency
        const resultDiv = document.getElementById('verticalSumResult');
        const totalRowSelect = document.getElementById('totalRowSelect');
        const selectedTotalIndex = totalRowSelect.value;
        if (selectedTotalIndex === "") { resultDiv.innerHTML = '<p class="error">è«‹é¸æ“‡ç¸½è¨ˆåˆ—ã€‚</p>'; return; }
        const totalRowData = this.parsedTableData[selectedTotalIndex];
        const detailCheckboxes = document.querySelectorAll('#tabularResultTable .detail-checkbox:checked');
        if (detailCheckboxes.length === 0) { resultDiv.innerHTML = '<p class="error">è«‹å‹¾é¸è‡³å°‘ä¸€å€‹æ˜ç´°åˆ—ã€‚</p>'; return; }
        let sums = { prev1: 0, prev2: 0, A: 0, B: 0, C: 0 };
        let hasPercentageMismatch = false;
        detailCheckboxes.forEach(checkbox => {
            const rowIndex = checkbox.dataset.rowIndex;
            const signSelect = checkbox.closest('tr').querySelector('.detail-sign');
            const multiplier = (signSelect && signSelect.value === 'subtract') ? -1 : 1;
            const detailData = this.parsedTableData[rowIndex];
            if (detailData.isPercentABC !== totalRowData.isPercentABC) { hasPercentageMismatch = true; }
            for (const key in sums) { if (typeof detailData[key] === 'number' && !isNaN(detailData[key])) { sums[key] += detailData[key] * multiplier; } }
        });
        if (hasPercentageMismatch) { resultDiv.innerHTML = '<p class="error">éŒ¯èª¤ï¼šå‹¾é¸é …ç›®å–®ä½ä¸ä¸€è‡´ã€‚</p>'; return; }
        
        let resultHtml = `<table id="verticalSumResultTable"><thead><tr><th>é …ç›®</th><th>å‰å¹´åº¦æ±ºç®—</th><th>ä¸Šå¹´åº¦é ç®—</th><th>ä¸»ç®¡æ ¸åˆ— (A)</th><th>æ“¬å¢æ¸› (B)</th><th>æ“¬æ ¸åˆ— (C)</th></tr></thead><tbody>`;
        const columns = ['prev1', 'prev2', 'A', 'B', 'C'];
        const rows = [ { label: 'æ˜ç´°åŠ ç¸½', data: sums }, { label: 'é¸å®šç¸½è¨ˆåˆ—', data: totalRowData }, { label: 'å·®ç•°', data: {} } ];
        columns.forEach(col => {
            const sum = rows[0].data[col];
            const total = rows[1].data[col];
            let diff = (typeof sum === 'number' && typeof total === 'number') ? total - sum : NaN;
            if (!isNaN(diff) && Math.abs(diff) < 0.00001) { diff = 0; }
            rows[2].data[col] = diff;
        });
        rows.forEach(row => {
            resultHtml += `<tr><td>${row.label}</td>`;
            columns.forEach(col => {
                let value = row.data[col];
                let isPercent = (col === 'A' || col === 'B' || col === 'C') ? totalRowData.isPercentABC : totalRowData[`is${col.charAt(0).toUpperCase() + col.slice(1)}Percent`];
                let formattedValue = (typeof value === 'number') ? Utils.formatNumberDisplay(value, isPercent) : 'N/A';
                let cellClass = row.label === 'å·®ç•°' ? (value === 0 ? 'correct' : 'error') : '';
                resultHtml += `<td class="${cellClass}">${formattedValue}</td>`;
            });
            resultHtml += `</tr>`;
        });
        resultHtml += '</tbody></table>';
        resultDiv.innerHTML = resultHtml;
    },
    generateTrendChart: function() {
        // Original logic adapted to new container ID
        const chartArea = document.getElementById('chartArea');
        chartArea.innerHTML = ''; 
        const selectedCheckboxes = document.querySelectorAll('#tabularResultTable .detail-checkbox:checked');
        if (selectedCheckboxes.length === 0) { alert('è«‹å…ˆå‹¾é¸é …ç›®ã€‚'); return; }
        
        selectedCheckboxes.forEach((checkbox) => {
            const rowIndex = checkbox.dataset.rowIndex;
            const rowData = this.parsedTableData[rowIndex];
            if (rowData.isPrev1Percent || rowData.isPercentABC) return;

            const change_1_to_2 = rowData.prev1 !== 0 ? ((rowData.prev2 - rowData.prev1) / Math.abs(rowData.prev1)) * 100 : null;
            const change_2_to_C = rowData.prev2 !== 0 ? ((rowData.C - rowData.prev2) / Math.abs(rowData.prev2)) * 100 : null;

            const div = document.createElement('div');
            div.style.cssText = "position:relative; height:300px; margin-bottom:20px; border:1px solid #eee; padding:10px;";
            const canvas = document.createElement('canvas');
            div.appendChild(canvas);
            chartArea.appendChild(div);

            new Chart(canvas.getContext('2d'), {
                type: 'bar',
                data: {
                    labels: ['å‰å¹´åº¦', 'ä¸Šå¹´åº¦', 'æ“¬æ ¸åˆ—'],
                    datasets: [
                        { type: 'bar', label: 'é‡‘é¡', data: [rowData.prev1, rowData.prev2, rowData.C], backgroundColor: 'rgba(54, 162, 235, 0.5)', yAxisID: 'y' },
                        { type: 'line', label: 'å¹´å¢ç‡', data: [null, change_1_to_2, change_2_to_C], borderColor: 'rgba(255, 99, 132, 1)', tension: 0.1, yAxisID: 'y1' }
                    ]
                },
                options: {
                    maintainAspectRatio: false,
                    plugins: { title: { display: true, text: rowData.item } },
                    scales: { y: { position:'left' }, y1: { position:'right' } }
                }
            });
        });
    }
};

// --- 5. Textual Verifier (å®Œå…¨ä¿ç•™åŸå§‹é‚è¼¯èˆ‡æ­£å‰‡è¡¨é”å¼) ---
const TextualVerifier = {
    M_AMT_UNITS: String.raw`å„„|è¬|åƒ|ä»Ÿ|ç™¾|ä½°|æ‹¾|å…ƒ`,
    get M_AMT_SRC() { return String.raw`(?:è³¸é¤˜|çŸ­çµ€)?\s*[\d,]+(?:${this.M_AMT_UNITS})?[\d,è¬åƒä»Ÿç™¾ä½°æ‹¾å…ƒ]*|ç„¡åˆ—æ•¸`; },
    M_OP_TYPES_SRC: String.raw`æš«å¢|æš«æ¸›|å¢åˆ—|æ¸›åˆ—|å¢|æ¸›|åˆª|è¿½åŠ |è¿½æ¸›|èª¿æ•´å¢åŠ |èª¿æ•´æ¸›å°‘|èª¿æ•´å¢åˆ—|èª¿æ•´æ¸›åˆ—`,
    get M_AGREE_PATTERN() { return new RegExp(String.raw`^(.*?)(${this.M_AMT_SRC})\s*ï¼Œ.*?æ“¬?(?:ä¾ä¸»ç®¡æ©Ÿé—œæ„è¦‹ï¼Œ)?(?:åŒæ„ç…§åˆ—|æš«ç…§åˆ—|æ‚‰æ•¸æ¸›åˆ—)`); },
    get M_STD_PATTERN() { return new RegExp(String.raw`^(.*?)(?:(?:ï¼š\s*ä¸»ç®¡æ©Ÿé—œæ ¸åˆ—|æ ¸åˆ—)\s*)?(${this.M_AMT_SRC})\s*ï¼Œ\s*(.*?)\s*(?:æ“¬\s*)?(${this.M_OP_TYPES_SRC})\s*(?:([^ï¼Œ0-9å…ƒå„„è¬åƒä»Ÿç™¾ä½°æ‹¾]*?)\s*)?(${this.M_AMT_SRC})\s*ï¼Œ\s*(?:æœ¬è™•æ ¸åˆ—|æ ¸åˆ—|æš«æ ¸åˆ—)\s*(${this.M_AMT_SRC})`); },
    get M_SMP_PATTERN() { return new RegExp(String.raw`^(.*?)(${this.M_AMT_SRC})\s*ï¼Œ\s*(.*?)\s*(?:æ“¬\s*)?(${this.M_OP_TYPES_SRC})\s*(?:([^ï¼Œ0-9å…ƒå„„è¬åƒä»Ÿç™¾ä½°æ‹¾]*?)\s*)?(${this.M_AMT_SRC})\s*ï¼Œ\s*(?:æœ¬è™•æ ¸åˆ—|æ ¸åˆ—|æš«æ ¸åˆ—)\s*(${this.M_AMT_SRC})`); },
    parseMoneyString: function(moneyStr) { if (!moneyStr || typeof moneyStr !== 'string') return null; let originalFullStr = moneyStr.trim(); let processedStr = moneyStr.trim(); if (processedStr === "ç„¡åˆ—æ•¸") return 0; let isDeficit = false; if (processedStr.startsWith("çŸ­çµ€")) { isDeficit = true; processedStr = processedStr.substring("çŸ­çµ€".length).trim(); } else if (processedStr.startsWith("è³¸é¤˜")) { processedStr = processedStr.substring("è³¸é¤˜".length).trim(); } let total = 0; let tempStr = processedStr.replace(/å…ƒ|,/g, ''); const units = [{ unit: "å„„", value: 100000000 },{ unit: "è¬", value: 10000 },{ unit: "åƒ", alt: "ä»Ÿ", value: 1000 },{ unit: "ç™¾", alt: "ä½°", value: 100 },{ unit: "æ‹¾", value: 10 }]; for (const u of units) { const regex = new RegExp(`([\\d.]+)(${u.unit}${u.alt ? '|' + u.alt : ''})`); const match = tempStr.match(regex); if (match) { total += parseFloat(match[1]) * u.value; tempStr = tempStr.replace(match[0], ''); } } if (tempStr.length > 0 && !isNaN(parseFloat(tempStr))) { total += parseFloat(tempStr); } else if (tempStr.length > 0 && tempStr.match(/[^\d.]/)) { if (total === 0 && originalFullStr !== "0" && !originalFullStr.toLowerCase().includes("ç„¡åˆ—æ•¸")) { return null;}} if (isDeficit && total > 0) { total *= -1; } if (total === 0 && originalFullStr !== "0" && !originalFullStr.toLowerCase().includes("ç„¡åˆ—æ•¸") && !(originalFullStr.startsWith("è³¸é¤˜") && processedStr === "0") && !(originalFullStr.startsWith("çŸ­çµ€") && processedStr === "0") ) { if (tempStr.replace(/\./g, '').match(/[^\d]/)) {return null;}} return total; },
    cleanDescription: function(desc) { if (!desc) return ""; return desc.replace(/^\s*[\dä¸€äºŒä¸‰å››äº”å…­ä¸ƒå…«ä¹åç”²ä¹™ä¸™ä¸æˆŠå·±åºšè¾›å£¬ç™¸å­ä¸‘]+\s*[\.ã€ï¼]?\s*(\uff08[ä¸€äºŒä¸‰å››äº”å…­ä¸ƒå…«ä¹åç”²ä¹™ä¸™ä¸æˆŠå·±åºšè¾›å£¬ç™¸å­ä¸‘]+\uff09|\([ä¸€äºŒä¸‰å››äº”å…­ä¸ƒå…«ä¹åç”²ä¹™ä¸™ä¸æˆŠå·±åºšè¾›å£¬ç™¸å­ä¸‘]+\))?\s*/, '').replace(/[ï¼š:\s]*$/, '').trim(); },
    checkContent: function() { 
        const rawText = document.getElementById('inputArea').value; 
        const originalLines = rawText.split('\n'); 
        let resultsHtml = `<table id="textualResultTable"><thead><tr><th>é …ç›®æè¿°</th><th>ä¸»ç®¡æ©Ÿé—œæ ¸åˆ—æ•¸ (A)</th><th>æ“¬å¢æ¸›åˆ—æ•¸ (B)</th><th>æ“¬æ ¸åˆ—æ•¸ (C)</th><th>ç³»çµ±è¨ˆç®— (A+B)</th><th>é©—è­‰çµæœ (A+B = C)</th></tr></thead><tbody>`; 
        const resultArea = document.getElementById('textualModeResults');
        let hasContent = false;
        
        for (const line of originalLines) {
            const trimmedLineOriginal = line.trim();
            if (trimmedLineOriginal === "" || trimmedLineOriginal.startsWith("#") || trimmedLineOriginal.startsWith("//")) continue;
            hasContent = true;
            let isParsable = false, matchedPatternType = null;
            
            if (trimmedLineOriginal.match(this.M_AGREE_PATTERN)) { isParsable = true; matchedPatternType = 'AGREE'; }
            else if (trimmedLineOriginal.match(this.M_STD_PATTERN)) { isParsable = true; matchedPatternType = 'STD'; }
            else if (trimmedLineOriginal.match(this.M_SMP_PATTERN)) { isParsable = true; matchedPatternType = 'SMP'; }
            
            if (!isParsable) { resultsHtml += `<tr><td style="text-align:left;">@@@ ${Utils.escapeHTML(trimmedLineOriginal)} @@@</td><td colspan="4" style="text-align:center; color: #777;">--- æ•˜è¿°å¥ï¼Œç•¥éè¨ˆç®— ---</td><td><span class="partial">ç•¥é</span></td></tr>`; continue; }
            
            // Logic for calculating sum (copied from original)
            let description = "", val1Str = "", val2Str = "", val3Str = "", status = "", note = ""; 
            let val1 = null, val2 = null, val3 = null, calculatedSum = null; 
            let matchToUse = null, opType = "", opDesc = "";

            if (matchedPatternType === 'AGREE') {
                 matchToUse = trimmedLineOriginal.match(this.M_AGREE_PATTERN); description = this.cleanDescription(matchToUse[1]); val1Str = matchToUse[2]; val1 = this.parseMoneyString(val1Str); 
                 if (trimmedLineOriginal.includes("æ‚‰æ•¸æ¸›åˆ—")) { val2Str = "æ‚‰æ•¸æ¸›åˆ—"; if (val1 !== null) { val2 = -val1; val3 = 0; } } 
                 else { val2 = 0; val2Str = "0å…ƒ (ç…§åˆ—)"; if (val1 !== null) val3 = val1; }
            } else {
                 matchToUse = trimmedLineOriginal.match(matchedPatternType === 'STD' ? this.M_STD_PATTERN : this.M_SMP_PATTERN);
                 description = this.cleanDescription(matchToUse[1]); val1Str = matchToUse[2]; opType = matchToUse[4]; val2Str = matchToUse[6]; val3Str = matchToUse[7];
                 val1 = this.parseMoneyString(val1Str); val2 = this.parseMoneyString(val2Str); val3 = this.parseMoneyString(val3Str);
                 if (val2 !== null && (opType.includes("æ¸›") || opType.includes("åˆª"))) val2 *= -1;
            }

            if (val1 !== null && val2 !== null) {
                calculatedSum = val1 + val2;
                if (val3 !== null) {
                    if (Math.abs(calculatedSum - val3) < 0.01) status = "<span class='correct'>æ­£ç¢º</span>";
                    else status = `<span class='incorrect'>éŒ¯èª¤</span>`;
                } else status = "<span class='partial'>éƒ¨åˆ†è§£æ</span>";
            } else status = "<span class='error'>è§£æå¤±æ•—</span>";

            resultsHtml += `<tr><td>${Utils.escapeHTML(description)}</td><td>${val1Str}</td><td>${val2Str}</td><td>${val3Str}</td><td>${calculatedSum!==null?Utils.formatNumberDisplay(calculatedSum):'-'}</td><td>${status}</td></tr>`;
        }
        resultsHtml += `</tbody></table>`;
        resultArea.innerHTML = hasContent ? resultsHtml : "<p>ç„¡æœ‰æ•ˆå…§å®¹ã€‚</p>";
        document.getElementById("resultContainer").classList.remove("hidden");
    }
};

// --- 6. Project Summator (å®Œå…¨ä¿ç•™åŸå§‹é‚è¼¯) ---
const ProjectSummator = {
    parseMoneyString: TextualVerifier.parseMoneyString, 
    sumProjectAmounts: function() {
        // Original final version logic with split fix
        const inputArea = document.getElementById('projectSumInput');
        const resultDiv = document.getElementById('projectSumResult');
        let totalSum = 0;
        let extractedItems = [];
        let itemIndex = 1;
        if (inputArea.value.trim() === "") { resultDiv.innerHTML = '<p>è«‹è¼¸å…¥å…§å®¹ã€‚</p>'; return; }
        
        let processedText = inputArea.value.trim().replace(/ï¼Œå…±\d+é …è¨ˆ.*/, '').replace(/å…ƒ\s*[\(ï¼ˆ][^)ï¼‰]*[\)ï¼‰]/g, 'å…ƒ').replace(/\s+/g, ' ');
        const initialItems = processedText.split(/[ã€åŠ]/);
        const finalItems = [];
        let delimiterIndex = 0;
        const delimiters = processedText.match(/[ã€åŠ]/g) || [];

        initialItems.forEach(item => {
            const trimmedItem = item.trim();
            if (!trimmedItem) return;
            if (finalItems.length > 0 && finalItems[finalItems.length - 1].includes('ã€Œ') && !finalItems[finalItems.length - 1].includes('ã€')) {
                const delimiter = delimiters[delimiterIndex -1] || 'åŠ';
                finalItems[finalItems.length - 1] += delimiter + trimmedItem;
            } else {
                finalItems.push(trimmedItem);
                delimiterIndex++;
            }
        });

        let resultHtml = '<h4>åŠ ç¸½çµæœ</h4><table style="width:100%;"><thead><tr><th>é …ç›®</th><th>é‡‘é¡</th><th>ç‹€æ…‹</th></tr></thead><tbody>';
        finalItems.forEach(itemText => {
            const textToParse = itemText.trim();
            const M_MONEY_PART = String.raw`[\d,]+\s*(?:äº¿|è¬|åƒ|ä»Ÿ|ç™¾|ä½°|æ‹¾|å…ƒ)?[\d,è¬åƒä»Ÿç™¾ä½°æ‹¾å…ƒ]*å…ƒ`;
            const moneyExtractorRegex = new RegExp(`(${M_MONEY_PART})`);
            const match = textToParse.match(moneyExtractorRegex);
            
            if (match) {
                const amount = this.parseMoneyString(match[1]);
                if (typeof amount === 'number' && !isNaN(amount)) {
                    totalSum += amount;
                    resultHtml += `<tr><td>${Utils.escapeHTML(textToParse)}</td><td>${Utils.formatNumberDisplay(amount)}</td><td class="correct">æˆåŠŸ</td></tr>`;
                } else {
                    resultHtml += `<tr><td>${Utils.escapeHTML(textToParse)}</td><td>-</td><td class="error">è§£æå¤±æ•—</td></tr>`;
                }
            } else {
                resultHtml += `<tr><td>${Utils.escapeHTML(textToParse)}</td><td>-</td><td class="partial">ç„¡é‡‘é¡</td></tr>`;
            }
        });
        
        resultHtml += `</tbody></table><p style="margin-top:10px; font-weight:bold;">ç¸½è¨ˆï¼š${Utils.formatNumberDisplay(totalSum)} å…ƒ (${Utils.formatChineseMoneyDisplay(totalSum)})</p>`;
        resultDiv.innerHTML = resultHtml;
    },
    clearProjectData: function() {
        document.getElementById('projectSumInput').value = '';
        document.getElementById('projectSumResult').innerHTML = '';
    }
};

// --- 7. Main ---
const App = {
    runVerification: function() {
        UIManager.showLoading(true);
        setTimeout(() => {
            try {
                const mode = document.querySelector('input[name="verifierMode"]:checked').value;
                if (mode === "tabular") TabularVerifier.calculate();
                else TextualVerifier.checkContent();
            } catch (e) {
                console.error(e);
                alert("é©—ç®—ç™¼ç”ŸéŒ¯èª¤ï¼Œè«‹æª¢æŸ¥è³‡æ–™æ ¼å¼ã€‚");
            } finally {
                UIManager.showLoading(false);
            }
        }, 10);
    }
};

document.addEventListener('DOMContentLoaded', () => { UIManager.updateMode(); });
</script>
</body>
</html>
